<!-- PHP weak comparision -->
<!-- 使用 PHP 弱类型比较 进行绕过 -->
# PHP 弱类型比较

https://ctf.mukeran.cn/web/notes/3

前言
====
PHP中有 `==` 和 `===` 两种比较相等的方法，前者为弱类型比较，即只根据一些规则比较其值是否在规则下相同(数值优先)，后者为强类型比较，比较时不仅要求值完全相同，还要比较类型是否相同。故根据这个特性，我们常常会遇到一些"矛盾"题目。这些比较条件放在其他语言可能还是真的矛盾，但是在 PHP 里面因为有弱类型比较，它们事实上是不矛盾的。

适用范围
====
弱类型比较仅适用于**字符串与字符串**以及**数与字符串**的比较

比较原则(强制转换)
====
从我的角度来看，我认为 PHP 的弱类型比较是以数优先的，也就是字符串会优先被强制转换成一个数字进行比较。  
**当数字与字符串进行比较时**：  
1. 当字符串以字母开头，如 `admin` 时，会被强制转化为 `0`;
2. 当字符串以数字开头时，会按照下面的原则将其开头的数字相关字符转化为数;
3. 如果字符串没有包含 `.`, `e`, `E`，且数值在整型范围之内，字符串会被转化为整型数字;
4. 如果字符串中包含 `.`, `e`, `E`，或者超出整型范围，字符串会被转化为浮点型数字。

**当字符串与字符串进行比较时**：  
若字符串为合法数字的表现形式(纯数字，小数，科学计数法；此时字符串中有其他不合法字符则不为合法数字，因为已经不会强制转换)，会转化为数字进行比较;

例子
====
**当数字与字符串进行比较时**：  
1. `"admin" == 0` -> `true`
2. `"1admin" == 1` -> `true`
3. `"0e20admin" == 0` -> `true`
4. `"0e30" == 0` -> `true`
5. `"1.0" == 1` -> `true`
6. `"1.1" == 1` -> `false`, `"1.1admin" == 1` -> `false`

相当于字符串的强制转换  
  
**当字符串与字符串进行比较时**：
1. `"0e30" == "0e20"` -> `true`
2. `"1.0" == "1"` -> `true`
3. `"1admin" == "1"` -> `false`

如果字符串不符合上面所说的条件，那么比较就变成字符串比较了

运用
====
CTF 的一些代码审计题目常常会涉及一些矛盾的问题，这个时候运用 PHP 的弱类型比较的特点，我们就可以进行绕过。
  
**`!is_numeric($num)` 和 `$num == 1` 的矛盾**：  
虽然字符串和数字比较时会被强制转换，但是在其他大多数情况下，它还是字符串  
对于 `"1admin"` 这种形式的字符串，在 `is_numeric` 函数进行判定时，并不被认为是数字(当然 `"1"` 在 `is_numeric` 下面会被认为是数字)  
下面一段代码：  
```php
$num = $_GET['num'];
if(!is_numeric($num)) {
    if($num == 1)
        echo $flag;
    else
        echo 'oh no!';
}
```
这种情况下，我们就可以构造 `$num = "1test"`，这样根据上面的原则，这个矛盾就被我们破解了。  
  
**`md5($a) == md5($b)` 的矛盾**：  
md5 设计出来就是为了得到一个文件的摘要，并且这个摘要重复的可能性极小。所以说在有限的时间里面，我们很难找到一个字符串的 md5 和另一个字符串相等。  
但是有的 md5 值会以 `0e` 开头。这种情况下，根据上面的原则，两个字符串如果都以 `0e` 开头，那么他们将被视为数字，而 0 的非负次方都被定义为 0 了，所以我们可以用这个特性来绕过判定 md5 值相等的检测。  
这里贴出一份目前现有的好用的 md5 为 `0e` 开头的字符串表：  

|String      |MD5                             |Advantage|
|------------|--------------------------------|---------|
|240610708   |0e462097431906509019562988736854|纯数字   |
|QNKCDZO     |0e830400451993494058024219903391|纯大写字母|
|s878926199a |0e545993274517709034328855841020|s, a结尾 |
|s155964671a |0e342768416822451524974117254469|s, a结尾 |
|s214587387a |0e848240448830537924465865611904|s, a结尾 |
|s878926199a |0e545993274517709034328855841020|s, a结尾 |
|s1091221200a|0e940624217856561557816327384675|s, a结尾 |
|s1885207154a|0e509367213418206700842008763514|s, a结尾 |

例如下面一段代码：
```php
$username = $_POST['username'];
$password = $_POST['password'];
if($username != $password) {
    if(md5($username) == md5($password))
        echo $flag;
    else
        echo 'never give up!';
}
```
使用上面表中的任意两个即可绕过检测  
  
同样还有许多其他的函数，在没有给定强比较参数为 `true` 时(比如 `array_search `)，也是使用的 `==` 弱比较，我们同样可以利用这一性质。

相关题目
====
|题目                                                            |类型             |
|---------------------------------------------------------------|-----------------|
|[矛盾-Bugku](http://ctf.bugku.com/challenges#%E7%9F%9B%E7%9B%BE)|`is_numeric` 矛盾|
