<!-- CBC 翻转攻击 -->
<!-- 和 aes-128-cbc 有关的攻击 -->
# CBC 翻转攻击 | 和 aes-128-cbc 有关的攻击

https://ctf.mukeran.cn/web/notes/7

前言
====
AES 是一个常用的对称加密算法。其有一种加密模式为CBC(密码分组链接模式)，其加密模式如下图：
![AES-CBC 加密算法流程](https://ctf.mukeran.cn/static/img/Web_Note_7_1.png)  
此算法存在安全问题，也就是可以进行翻转攻击，但是利用这个漏洞需要一定条件，在一般情况下并不容易利用。

分析
====
根据上图，我们可以分析：CBC 加密模式是先指定一个 Initialization Vector(IV) 作为第一组明文的异或对象，再将异或对象进行 AES 轮加密(在这里不需要理解 AES 轮加密内容)，然后将加密后的密文作为下一组明文的异或对象，如此重复，得到每一组密文，进行拼接，得到最终密文。对于 AES-128，我们的每一个明文分组是 16 字节(也就是 128 位)。解密时为该加密过程的逆过程(因为异或运算和 AES 轮加密都是可逆的)，如图：
![AES-CBC 解密算法流程](https://ctf.mukeran.cn/static/img/Web_Note_7_2.png)  
我们可以看到，每一组密文会作为下一组密文的异或对象，而异或运算有这样的性质：  
> a xor a = 0  
> a xor 0 = a  

那么我们可以利用这个性质，通过修改前一组密文内容来使后一组解密后明文成为任意指定值：
> 已知：前一组密文某一字符 xor 后一组解密后得到序列对应字符 = 后一组明文对应字符  
> 可得：任意字符 = 前一组密文某一字符 xor 后一组解密后得到序列对应字符 xor 后一组明文对应字符 xor 任意字符  
> 只需让： 前一组密文某一字符 = 前一组密文某一字符 xor 后一组明文对应字符 xor 任意字符

![AES-CBC 翻转攻击原理](https://ctf.mukeran.cn/static/img/Web_Note_7_3.png)

但这样，如果由于前一组密文的改变，经过 AES 轮解密后的明文改变了。对于有些题目或者数据，这样的操作可能并不会对结果产生影响，但是如果题目加密的内容是前后相关的或者有格式的，那么可能就不能正常地得到结果。那么这个时候我们就需要对前一组进行修复，这样事实上会影响到所有前面的组，我们需要用相同的方法进行连续推算，一组一组往前推算如果我们要修复的一组内容。由于第一组的异或对象 IV 是可以由我们制定的，那么我们可以最后可以推算到一个可以自定义的 IV 使得最后明文变成我们想要的值。假设我们改变的就是第一组的密文，我们分析一下：
> 我们知道：IV 某一字符 xor 改变后第一组解密后对应字符 = 明文对应字符  
> 需要已知：改变后第一组加密后序列  
> 可得：任意字符 = IV 某一字符 xor 改变后第一组解密后对应字符 xor 明文对应字符 xor 任意字符  
> 只需让：IV 某一字符 = IV 某一字符 xor 明文对应字符 xor 任意字符

这个情况下，我们要修复全文一定要知道我们改变后密文通过相同密钥轮解密后的序列，不然我们就无法修复全文。  
根据上面的分析内容，我们就可以进行 CBC 翻转攻击了。

题目
====
|名称-来源|类型|WriteUp|
|--------|---|--------|
|[login4 - Bugku](https://ctf.bugku.com/challenges#login4)|CBC 翻转攻击|[Web_WriteUp_5](https://ctf.mukeran.cn/web/writeups/5)|